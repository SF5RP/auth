## Интергация с Auth-сервисом (для других микросервисов)Этот документ описывает, как из другого микросервиса авторизироваться через данный Auth-сервис и как получать данные списка персонажей.### Базовая информация- Бэкенд Auth: `Go + Gin`- OAuth провайдер: Discord (через маршруты `/login`, `/callback`)- Выдача JWT: access (15 минут), refresh (7 дней)- Валидация: `Authorization: Bearer <access_jwt>`- Публичные ручки:  - `GET /health`  - `GET /login` (редирект на Discord)  - `GET /callback` (обработка OAuth)  - `POST /refresh` (обновление access по refresh)- Защищённые ручки (требуют JWT):  - `GET /me` (текущий пользователь)  - `GET /admin/...` (для ролей с правами admin)Переменные окружения (важные):- `JWT_SECRET` — секрет для подписи и валидации JWT (HS256)- `FRONTEND_URL` — для CORS### Поток аутентификации пользователя (через фронтенд)1. Клиент идёт на фронтенд `/login` → фронт обращается к бэкенду `GET /login` → редиректит на Discord OAuth.2. Discord возвращает `code` на `GET /callback`.3. Бэкенд обменивает `code` на OAuth токены Discord, вытягивает профиль, создаёт/обновляет пользователя и генерирует:   - Access JWT (15 минут)   - Refresh token (рандомный, хранится в БД, 7 дней)4. На стороне Auth ставится HttpOnly-cookie с refresh-токеном; access не передаётся в URL. Далее фронт/клиенты шлют `Authorization: Bearer <access>`, получая access через `/refresh`.### Хранение токенов и cookies- Refresh-токен хранится в защищённой cookie: HttpOnly; Secure; SameSite=Lax (или None + Secure при кросс-домене); Path=/; Max-Age=7d.- Access-токен короткоживущий и не хранится в cookie. Клиент запрашивает его по требованию через `POST /refresh` (браузер приложит cookie автоматически при `credentials: include`).Пример заголовка установки cookie (ответ `/callback` и, при ротации, `/refresh`):```Set-Cookie: refreshToken=<token>; HttpOnly; Secure; SameSite=Lax; Path=/; Max-Age=604800```Структура клеймов access JWT (пример):```sub: <user_id>role: <user_role> (user|admin|moderator)exp: <unix_ts>iat: <unix_ts>```### Межсервисная интеграция (server-to-server)Если у вас есть бэкенд‑микросервис, которому нужно проверять доступ пользователя на основании уже выданного access JWT, используйте следующую схему:- Клиент (браузер/мобильный) получает `access` от Auth-сервиса (через описанный выше фронтовый поток)- Клиент прикладывает этот `access` к запросам в ваш сервис: `Authorization: Bearer <access>`- Ваш сервис не должен доверять токену «на слово» — валидируйте его локально с использованием общего секрета `JWT_SECRET` из Auth-сервиса (алгоритм HS256)Псевдокод валидации JWT (Go):```go// use github.com/golang-jwt/jwt/v5token, err := jwt.Parse(tokenString, func(t *jwt.Token) (interface{}, error) {    return []byte(os.Getenv("JWT_SECRET")), nil})if err != nil || !token.Valid { /* 401 */ }claims := token.Claims.(jwt.MapClaims)userID := claims["sub"]role := claims["role"]// применяйте свою бизнес-логику на основе роли/идентификатора```Альтернатива: проксировать проверку в Auth-сервис через middleware‑ручку — в текущей версии проекта такой публичной «/introspect» ручки нет, поэтому рекомендуем локальную валидацию по общему секрету.Обновление access токена:- Когда access истёк, клиент вызывает `POST /refresh` с `credentials: include`; бэкенд читает refresh из HttpOnly-cookie и возвращает новый access.- Межсервисная интеграция не хранит refresh; только фронт освежает access и затем вновь обращается к вашим сервисам.Клиентский псевдокод получения access:```tslet accessToken: string | null = null;async function getAccess() {  if (accessToken) return accessToken;  const res = await fetch(`${API}/refresh`, {    method: "POST",    credentials: "include",  });  if (!res.ok) throw new Error("unauthorized");  const { access_token } = await res.json();  accessToken = access_token;  return accessToken;}```### Роли и доступ- Клейм `role` присутствует в access JWT.- Ваш сервис может проверять роль для ограничения доступа (например, требовать `admin`).Пример проверки роли (псевдокод):```goif role != "admin" { /* 403 */ }```### Эндпоинты Auth-сервиса (кратко)- `GET /health` — проверка доступности- `GET /login` — редирект на Discord OAuth- `GET /callback` — обмен `code` на пользователя и выдача токенов- `POST /refresh` — читает refresh из HttpOnly-cookie; ответ — `{ access_token }`. Может ротировать refresh и обновить cookie.- `GET /me` — требует `Authorization: Bearer <access>`Пример запроса к защищённому эндпоинту:```bashcurl -H "Authorization: Bearer $ACCESS" https://auth.example.com/me```Ответ (пример):```json{  "id": "123",  "username": "SomeUser",  "role": "user"}```### Данные списка персонажейВ текущем репозитории список персонажей используется во фронтенде как статический мок. Источник: `frontend/src/shared/lib/characters.ts`.- Функция получения по `serverId`:```tsexport function getCharactersByServerId(serverId: number): Character[] {  return STATIC_CHARACTERS.filter((c) => c.serverId === serverId);}```- Пример использования во фронте (React Query хук): `frontend/src/features/characters/hooks.ts````tsexport function useCharacters(serverId: number) {  return useQuery<Character[]>({    queryKey: ["characters", serverId],    queryFn: async () => getCharactersByServerId(serverId),    enabled: Number.isFinite(serverId),  });}```Важно: в текущей версии список персонажей не выдаётся бекендом Auth‑сервиса. Если вам нужен межсервисный доступ к персонажам:1. Создайте в вашем игровом/доменных сервисах REST‑ручку, например: `GET /servers/{serverId}/characters`.2. Защитите её JWT‑middleware (как описано выше).3. Пусть фронтенд/клиенты отправляют `Authorization: Bearer <access>`.Пример целевого эндпоинта в вашем сервисе:```httpGET /servers/{serverId}/charactersAuthorization: Bearer <access>```Ответ (пример):```json[  { "id": "c001", "name": "Alex Mercer", "level": 12, "serverId": 1 },  { "id": "c002", "name": "Nina Price", "level": 8, "serverId": 1 }]```Если вы хотите, чтобы сам Auth‑сервис проксировал список персонажей, предусмотрите отдельный микросервис персонажей и добавьте в Auth‑бэкенд защищённый прокси‑эндпоинт, валидирующий JWT и дергающий тот сервис по внутреннему адресу.### Быстрый чек‑лист интегратора- Иметь общий `JWT_SECRET` для валидации access JWT- Проверять `Authorization: Bearer` на входе ваших ручек- Использовать `role` для ограничений- Не хранить refresh на бэкендах‑интеграторах; обновление делает фронт через `/refresh`- Для персонажей — реализовать доменный сервис и защищённую ручку; текущий фронт использует мок